from fastapi import APIRouter, Depends, HTTPException, status
from typing import Dict, List
import json
from datetime import datetime

from routes.auth import get_current_user
from config.database import get_db
from services.anti_scam_service import AntiScamService

router = APIRouter()

@router.post("/send-message")
async def send_message(
    message_data: dict,
    current_user: dict = Depends(get_current_user),
    db = Depends(get_db)
):
    """Send message with enhanced features"""
    try:
        match_id = message_data.get('match_id')
        content = message_data.get('content', '').strip()
        message_type = message_data.get('message_type', 'text')
        
        if not match_id or not content:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Match ID and content are required"
            )
        
        # Verify match exists and user is part of it
        match = await db.fetchone(\"\"\"\n            SELECT * FROM matches \n            WHERE id = ? AND (user1_id = ? OR user2_id = ?)\n        \"\"\", (match_id, current_user[\"id\"], current_user[\"id\"]))\n        \n        if not match:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Match not found\"\n            )\n        \n        # Anti-scam filtering\n        risk_score = await AntiScamService.analyze_message_risk(content)\n        is_flagged = risk_score > 70\n        \n        if is_flagged:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Message contains inappropriate content\"\n            )\n        \n        # Insert message\n        cursor = await db.execute(\"\"\"\n            INSERT INTO messages (match_id, sender_id, content, message_type, risk_score, is_flagged)\n            VALUES (?, ?, ?, ?, ?, ?)\n        \"\"\", (match_id, current_user[\"id\"], content, message_type, risk_score, is_flagged))\n        \n        message_id = cursor.lastrowid\n        await db.commit()\n        \n        # Update user activity\n        await db.execute(\"\"\"\n            UPDATE users SET last_active = CURRENT_TIMESTAMP WHERE id = ?\n        \"\"\", (current_user[\"id\"],))\n        await db.commit()\n        \n        return {\n            \"message_id\": message_id,\n            \"status\": \"sent\",\n            \"risk_score\": risk_score\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Failed to send message: {str(e)}\"\n        )\n\n@router.put(\"/message/{message_id}/read\")\nasync def mark_message_read(\n    message_id: int,\n    current_user: dict = Depends(get_current_user),\n    db = Depends(get_db)\n):\n    \"\"\"Mark message as read (read receipts)\"\"\"\n    try:\n        # Verify user can mark this message as read (recipient only)\n        message = await db.fetchone(\"\"\"\n            SELECT m.*, ma.user1_id, ma.user2_id \n            FROM messages m\n            JOIN matches ma ON m.match_id = ma.id\n            WHERE m.id = ?\n        \"\"\", (message_id,))\n        \n        if not message:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Message not found\"\n            )\n        \n        # Only recipient can mark as read\n        if message['sender_id'] == current_user[\"id\"]:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Cannot mark own message as read\"\n            )\n        \n        # Check if user is part of the match\n        if current_user[\"id\"] not in [message['user1_id'], message['user2_id']]:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Not authorized to read this message\"\n            )\n        \n        # Mark as read\n        await db.execute(\"\"\"\n            UPDATE messages \n            SET is_read = TRUE, read_at = CURRENT_TIMESTAMP \n            WHERE id = ?\n        \"\"\", (message_id,))\n        await db.commit()\n        \n        return {\"message\": \"Message marked as read\"}\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Failed to mark message as read: {str(e)}\"\n        )\n\n@router.post(\"/message/{message_id}/react\")\nasync def add_message_reaction(\n    message_id: int,\n    reaction_data: dict,\n    current_user: dict = Depends(get_current_user),\n    db = Depends(get_db)\n):\n    \"\"\"Add reaction to message\"\"\"\n    try:\n        reaction_type = reaction_data.get('reaction_type')  # 'heart', 'laugh', 'wow', 'sad', 'angry'\n        \n        if not reaction_type:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Reaction type is required\"\n            )\n        \n        valid_reactions = ['heart', 'laugh', 'wow', 'sad', 'angry', 'thumbs_up']\n        if reaction_type not in valid_reactions:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Invalid reaction type. Must be one of: {valid_reactions}\"\n            )\n        \n        # Get current message\n        message = await db.fetchone(\"\"\"\n            SELECT m.*, ma.user1_id, ma.user2_id \n            FROM messages m\n            JOIN matches ma ON m.match_id = ma.id\n            WHERE m.id = ?\n        \"\"\", (message_id,))\n        \n        if not message:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Message not found\"\n            )\n        \n        # Check if user is part of the match\n        if current_user[\"id\"] not in [message['user1_id'], message['user2_id']]:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Not authorized to react to this message\"\n            )\n        \n        # Get current reactions\n        current_reactions = json.loads(message['reactions'] or '{}')\n        \n        # Add/update user's reaction\n        current_reactions[str(current_user[\"id\"])] = reaction_type\n        \n        # Update message with new reactions\n        await db.execute(\"\"\"\n            UPDATE messages SET reactions = ? WHERE id = ?\n        \"\"\", (json.dumps(current_reactions), message_id))\n        await db.commit()\n        \n        return {\n            \"message\": \"Reaction added\",\n            \"reactions\": current_reactions\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Failed to add reaction: {str(e)}\"\n        )\n\n@router.get(\"/match/{match_id}/messages\")\nasync def get_match_messages(\n    match_id: int,\n    limit: int = 50,\n    offset: int = 0,\n    current_user: dict = Depends(get_current_user),\n    db = Depends(get_db)\n):\n    \"\"\"Get messages for a match with enhanced data\"\"\"\n    try:\n        # Verify match exists and user is part of it\n        match = await db.fetchone(\"\"\"\n            SELECT * FROM matches \n            WHERE id = ? AND (user1_id = ? OR user2_id = ?)\n        \"\"\", (match_id, current_user[\"id\"], current_user[\"id\"]))\n        \n        if not match:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=\"Match not found\"\n            )\n        \n        # Get messages with enhanced data\n        messages = await db.fetchall(\"\"\"\n            SELECT m.*, u.name as sender_name\n            FROM messages m\n            JOIN users u ON m.sender_id = u.id\n            WHERE m.match_id = ?\n            ORDER BY m.created_at DESC\n            LIMIT ? OFFSET ?\n        \"\"\", (match_id, limit, offset))\n        \n        enhanced_messages = []\n        for msg in messages:\n            msg_dict = dict(msg)\n            \n            # Parse reactions\n            reactions = json.loads(msg_dict.get('reactions') or '{}')\n            \n            # Add reaction summary\n            reaction_summary = {}\n            for user_id, reaction in reactions.items():\n                if reaction not in reaction_summary:\n                    reaction_summary[reaction] = 0\n                reaction_summary[reaction] += 1\n            \n            msg_dict['reactions'] = reactions\n            msg_dict['reaction_summary'] = reaction_summary\n            msg_dict['is_own_message'] = msg_dict['sender_id'] == current_user[\"id\"]\n            \n            enhanced_messages.append(msg_dict)\n        \n        return {\n            \"messages\": enhanced_messages,\n            \"total_count\": len(enhanced_messages)\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Failed to get messages: {str(e)}\"\n        )\n\n@router.get(\"/typing-status/{match_id}\")\nasync def get_typing_status(\n    match_id: int,\n    current_user: dict = Depends(get_current_user)\n):\n    \"\"\"Get typing status for match (placeholder for WebSocket implementation)\"\"\"\n    # This would be implemented with WebSocket for real-time typing indicators\n    return {\"typing_users\": []}\n\n@router.post(\"/typing-status/{match_id}\")\nasync def update_typing_status(\n    match_id: int,\n    typing_data: dict,\n    current_user: dict = Depends(get_current_user)\n):\n    \"\"\"Update typing status (placeholder for WebSocket implementation)\"\"\"\n    # This would be implemented with WebSocket for real-time typing indicators\n    return {\"message\": \"Typing status updated\"}